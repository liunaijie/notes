/**
 * 不同的二叉搜索树
 *
 * @author ：LiuNaiJie
 * @date ：2020-03-26
 */
public class T96 {

	/**
	 * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
	 * 示例:
	 * 输入: 3
	 * 输出: 5
	 * 解释:
	 * 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
	 * <p>
	 * 1         3     3      2      1
	 * \       /     /      / \      \
	 * 3     2     1      1   3      2
	 * /     /       \                 \
	 * 2     1         2                 3
	 */

	/**
	 * 一个有序序列，构建一颗二叉搜索树
	 * 我们可以依次使用每个数字`i`作为根节点
	 * 那么`1~i-1`为左子树，`i+1~n`为右子树
	 * 并且 （1，2，3）跟（4，5，6）构建不同类型的数量是一致的，也就是说长度固定时的数量是固定的。
	 * 可以用数组a[]来保存，并且可知a[0]=1,a[1]=1，即0个元素和一个元素都只有一种排列方法
	 * 那么a[n]就是长度为n时不重复的数量
	 * 对于`i`作为根节点时，它的不重复数量为 count(left)*count(right) 也就是 a[i-1]*a[n-i]
	 * 所以当长度为`n`个时，它的数量就是从`1~n`的累加
	 *
	 * @param n
	 * @return
	 */
	public int numTrees(int n) {
		int[] a = new int[n + 1];
		a[0] = a[1] = 1;
		//从a[2]开始求
		for (int i = 2; i <= n; i++) {
			//从1~i，都可以作为根节点，所以i的次数是1~i次数的累加。
			for (int j = 1; j <= i; ++j) {
				//对于第i次，它作为根节点时的数量是 a[j-1]*a[i-j]
				a[i] += a[j - 1] * a[i - j];
			}
		}
		return a[n];
	}

}
